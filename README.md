# Redis

Цель задания – разработать приложение имплементацию in-memory Redis кеша.

## Необходимый функционал:

* Клиент и сервер tcp(telnet)/REST API
* Key-value хранилище строк, списков, словарей
* Возможность установить TTL на каждый ключ
* Реализовать операторы: GET, SET, DEL, KEYS
* Реализовать покрытие несколькими тестами функционала

##Дополнительно (необязательно):

* Реализовать операторы: HGET, HSET, LGET, LSET
* Реализовать сохранение на диск
* Масштабирование (на серверной или на клиентское стороне)
* Авторизация
* Нагрузочные тесты


##REST API server:

Для запуска сервера нужно использовать команду `docker-compose up`. При запуске будут созданы хендлеры и конструкторы кэша, которые зададут начальные значения для простоты использования.
В обычном Redis реализованы все команды отдельно для каждого типа данных, в моей реализации существуют 4 разных типа хранилищ. Отдельно для строк, списков, словарей и общий для всех этих типов.
То есть, реализованые команды LSET, LGET и т.д. добавляют данные лишь в отдельное хранилище для списков. А команды SET, GET и т.д. для общего хранилища, добавление в хранилище по ключу, в котором уже есть данные происходит через команду APPEND.

##Функционал:

API принимает данные в формате JSON и возвращает строку с результатом.
В случае успешного запроса возвращается статус-200, при ошибке-400, а при использовании другого метода-405.
На каждый ключ можно установить ttl в теле запроса, если не передать значение ttl то по умолчанию поставится значение -1.
При отправке каждого запроса нужно задавать BasicAuth и передавать логин и пароль(admin,admin).
Сохранение производится в текстовый файл в этой же дирректории.

#Операторы:

| Оператор                | Метод | Url          | Body                                                         | Пример успешного ответаa                                                                | Пример ошибки                                                    |
|-----------------------|--------|--------------|--------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------|
| GET                  | GET    | /GET/{key}            | --                                                           | ["string","map","my_key"]                                                               | --                                                               |
| SET                   | PUT    | /SET         | {"key":"key1","valueS":"string","valueL":["a","b"],"valueD":{"key1":"value1","key2":"value2"}}                                                          | {"type": 1,"data": [1,"string",{"map": "of_something"},0.2,null,["nested","list",42,]]} | {"error": "key not found"}                                       |
| Get at index          | GET    | /key/index   | --                                                           | {"inner": {"one_more": {"key": "value"}}}                                               | {"error": "cant get item at index"}                              |
| Remove                | DELETE | /key         | --                                                           | "OK"                                                                                    | --                                                               |
| Set с ttl по умолчнию | POST   | /key         | {"a":42,"list":[1,{"hello":"world"}],"something":"anything"} | {"type":2,"data":{"a":42,"list":[1,{"hello":"world"}],"something":"anything"}}          | {"error":"invalid character 'a' looking for beginning of value"} |
| Set с ttl             | POST   | /key?ttl=10s | {"a":42,"list":[1,{"hello":"world"}],"something":"anything"} | {"type":2,"data":{"a":42,"list":[1,{"hello":"world"}],"something":"anything"}}          | {"error":"Malformed duration"}                                   |

