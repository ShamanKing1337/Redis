# Redis

Цель задания – разработать приложение имплементацию in-memory Redis кеша.

## Необходимый функционал:

- [x] Клиент и сервер tcp(telnet)/REST API
- [x] Key-value хранилище строк, списков, словарей
- [x] Возможность установить TTL на каждый ключ
- [x] Реализовать операторы: GET, SET, DEL, KEYS
- [x] Реализовать покрытие несколькими тестами функционала

## Дополнительно (необязательно):

- [x] Реализовать операторы: HGET, HSET, LGET, LSET
- [x] Реализовать сохранение на диск
- [ ] Масштабирование (на серверной или на клиентское стороне)
- [x] Авторизация
- [x] Нагрузочные тесты


## REST API server:

Для запуска сервера нужно использовать команду `docker-compose up`. При запуске будут инициализированы хендлеры и сервисы, которые управляют кэшем, которые зададут начальные значения для простоты использования. Сервер находтся на порте 4000

В обычном Redis реализованы все команды отдельно для каждого типа данных, в моей реализации существуют 4 разных типа хранилищ. Отдельно для строк, списков, словарей и общий для всех этих типов.

То есть, реализованые команды LSET, LGET и т.д. добавляют данные лишь в отдельное хранилище для списков. А команды SET, GET и т.д. для общего хранилища, добавление в хранилище по ключу, в котором уже есть данные происходит через команду APPEND.

## Функционал:

API принимает данные в формате JSON и возвращает строку с результатом.

В случае успешного запроса возвращается статус-200, при ошибке-400, а при использовании другого метода-405.

На каждый ключ можно установить ttl в теле запроса, если не передать значение ttl, то по умолчанию время жизни будет бесконечным.

При отправке каждого запроса нужно задавать BasicAuth и передавать логин и пароль(admin,admin).

Для сохранения нужно отправить запрос /SAVE. Сохранение производится в текстовый файл в дирректории проекта.

### Операторы:

| Описание               | Метод | Url          | Body                                                         | Пример успешного ответа                                                                                                                    |
|-----------------------|--------|--------------|--------------------------------------------------------------|-----------------------------------------------------------------------------------------|
| Достает значения по ключу                  | GET    | /GET/{key}            | --                                                           | Resp: &{ValueD:map[key1:value1 key2:value2] ValueL:[a b] ValueS:string ttl:-1}                                                            | --                                                               |
| Задает значения по ключу                  | POST    | /SET         | {"key":"key1","valueS":"string","valueL":["a","b"],"valueD":{"key1":"value1","key2":"value2"}}                                                          | Resp: OK                                  |
| Удаляет ключ и все значения         | DELETE    | /DEL/{key}  | --                                                           | Resp: OK                                                                            |
| Возвращает все ключи хранилища              | GET | /KEYS         | --                                                           | Resp: [key3 key5]                                                                                   | --                                                               |
| Задачет значения по ключу с временем жизни| POST   | /SET         | {"key":"key6","valueS":"string","ttl" : 20} |     Resp: OK       |
| Добавляет данные по существующему ключу          | PUT | /APPEND| {"key":"key6","valueL":["b","e"]}  | Resp: &{ValueD:map[key1:value1 key2:value2] ValueL:[a b b e] ValueS:string ttl:-1}                                     |


## Тестирование

Для тестирования функционала использовалась встроенная библиотека `testing`. Сравнивались возвращаемые значения функций с нужными результатами, если значения не совпадают, выдается ошибка и приложение не собирается.

Нагрузочное тестрование показало, что сервер способен обрабатывать лишь около 4000 запросов в секунду, из-за того что использовались мьютексы, чтобы данные не заменяли друг друга во время исполнения запроса. 
